(ns alphabet-cipher.coder)

(def alphabet
  "Generates the alphabet as a list of chars"
  (map char (range 97 123)))

(defn char-offset
  "Calculates the offset of a character from the letter a"
  [ch]
  (- (int ch) (int \a)))

(defn gen-offset-alphabet
  "Generates an alphabet offset by some number."
  [n]
  (take 26 (drop n (cycle alphabet))))

(defn encode-letter
  "Looks up the message character's position in the regular alphabet in the alphabet generated by the key and returns that character."
  [k m]
  (let [offset (char-offset k)
        position (char-offset m)
        offset-alphabet (gen-offset-alphabet offset)]
    (nth offset-alphabet position)))

(defn decode-letter
  "Looks up the position of the message character in the alphabet generated by the key in the regular alphabet and returns that character."
  [k m] 
  (let [offset (char-offset k)
        position-fn #(.indexOf % m)
        offset-alphabet (gen-offset-alphabet offset)
        position (position-fn offset-alphabet)]
    (nth alphabet position)))

(defn code-pairs
  "Generates pairs between the keyword and the message (doesn't care if the message is clear/cipher-text)"
  [keyword message]
  (partition 2 (interleave (cycle keyword) message)))

(defn apply-to-pairs
  "Applies either the decode-letter or encode-letter to each character pair"
  [func pairs]
  (apply str (map #(apply func %) pairs)))

(defn encode [keyword message]
  "Encodes a message given a keyword and a message."
  (apply-to-pairs encode-letter (code-pairs keyword message)))

(defn decode [keyword message]
  "Decodes a message given a keyword and a message."
  (apply-to-pairs decode-letter (code-pairs keyword message)))
